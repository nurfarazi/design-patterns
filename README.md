# Design patterns in c# and .net

# Design pattern

## Creational Design Patterns

### Factory Method

The Factory Pattern is a creational design pattern that provides an interface for creating objects but lets subclasses
decide which class to instantiate. In essence, it defers the object creation process to specialized "factory" classes.

## Structural Design Patterns

## Behavioral Design Patterns

## SOLID

SOLID is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also known as Uncle
Bob).

### Single Responsibility Principle (SRP)

#### Why should we use this principle?

- A class should have one and only one reason to change, meaning that a class should have only one job.
- A class should have only one responsibility.
- A class should have only one actor/concept.
- A class should have only one responsibility to change.
- A class should have only one reason to change.
- A class should have only one actor that changes.

### Open Closed Principle (OCP)

#### Why we should use this principle?

- Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
- A class should be open for extension but closed for modification.

### Liskov Substitution Principle (LSP)

#### Why we should use this principle?

- Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that
  program.
- A class should be replaceable by any of its subclasses without altering the correctness of the program.
- A class should be replaceable by any of its subtypes without altering the correctness of the program.

### Interface Segregation Principle (ISP)

#### Why we should use this principle?

- Many client-specific interfaces are better than one general-purpose interface.
- Many specific interfaces are better than one general interface.
- Many client-specific interfaces are better than one general-purpose interface.
- Many client-specific interfaces are better than one general interface.

### Dependency Inversion Principle (DIP)

#### Why we should use this principle?

- One should depend upon abstractions, not concretions.
- High-level modules should not depend on low-level modules. Both should depend on abstractions.
- Abstractions should not depend on details. Details should depend on abstractions.
